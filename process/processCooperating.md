# 进程间的协作,需要进程间通信(IPC)机制来允许它们交换数据和信息.

## 1. 低级通信和高级通信
    低级: 传递状态和整数值
        包括进程互斥和同步所采用的信号量和管程机制.
        但是, 传送信息量小,效率低;编程复杂(需要实现细节),易出错.
    高级: 能够传送任意数量的数据
        包括三类: 共享存储区, 管道, 消息.

## 2. 直接通信和间接通信
    直接: 直接传达接收方. 如管道
        收发双方方分别可以指定(可多个)和获取对方的地址
    间接: 借助收发双方进程之外的共享数据结构作为通信中转.如消息队列
        收发双方的数目可以任意.
    
    典型模型: 
    
        1. 生产者消费者模型:  (in & out)
            in到快满时,告知可out了

        2. 共享内存模型:
            在共享内存的进程间通信模型中,建立了一个由协作进程共享的内存区域.协作进程可以通过向共享区域读写数据来交换信息.
            例子: 路由器

        3. 消息传递模型:
            共享内存的进程间通信方案要求进程共享内存的一个区域,并且由应用程序编程人员显式地编写用于访问和操作共享内存的代码.
            实现相同效果的另一种方法就是通过OS提供的消息传递工具进行协作进程彼此通信的方法.
                至少要为进程通信提供两个操作: send, receive
                直接通信: send(P, message): Send a message to process P.
                        receive(Q, message):　Receive a message from process Q.
                间接通信: send(A, message):  
                        receive(A, message):  邮箱Ａ，相当于公共存储区域
            涉及同步：
                阻塞发送：　发送被阻塞
                非阻塞发送：　发送进程发送消息并继续操作
                阻塞接收：　接收方阻塞，直到消息可用为止．
                非阻塞接收：　无论是否有有效消息，接收方对消息进行检索（可能完整也可能不完整）
            
            缓冲机制：
                零缓冲：　队列最大长度为0, 即链路中不能有任何消息等待 
                    -> 发送方必须阻塞 -> 直至接收方收到
                    效率低!
                有界缓冲: 队列长度n有限, 最多n条消息可以驻留在缓冲区.
                    链路已满 -> 发送方阻塞等待.
                无界缓冲: 顾名思义, 一般不使用. (不安全)

        通常,许多系统中,共享内存和信息传递机制都会被实现 (2 & 3)
            1.信息传递适合小信息量的信息共享.
            2.消息传递机制易于实现.(使用系统调用实现, 内核操作耗时相对较长)
            3.共享内存速度快,因为只有建立内存区才需要内核调用.
            4.一旦共享内存区域建立,进程中对共享信息访问就是对内存访问.
                
                然而,对于具有多处理核心的系统,消息传递提供的性能较好.
                共享内存存在缓存一致性问题.(共享数据在多个缓存之间迁移,随着系统处理核心增多,会出现缓存一致性问题 -> 消息传递更好一些)