#include <semaphore.h>

/*
    用信号灯表示筷子
    哲学家对信号量, 通过P操作获取一根筷子, 通过V操作释放筷子
*/

semaphore chopstick[5] = {1, 1, 1, 1, 1}  // 用信号灯表示梅根筷子

void philosopher(int i) // 哲学家进程
{
    while (1){
        P(chopstick[i]);
        P(chopstick[(i+1) % 5]);
        eat();  // 进餐
        V(chopstick[i]);
        V(chopstick[(i+1) % 5]);
        think();  // 思考
    }
}
  // 这种方案可以保证没有两个邻居同时吃饭, 但不可取, 因为可能导致死锁
  /*
    假定优先级 A>B>C>D>E 
    优先取左筷子会变成轮流执行:ABCDE 
    优先取右筷子: ACEBD 
    (画图分析即可, 要注意中间的大米其实是临界区只允许一个进程访问)

    -> 这个方案易造成多个进程推进的速度和过程不理想,易造成死锁
        -> 需要合理安排信号量的申请与释放.

    几个可能的补救方法:
        1. 最多允许四个哲学家同时坐在桌边
        2. 允许一位哲学家在两根筷子都有的情况下拿起筷子(在临界区拿起??)
        3. 使用非对称的解决方案: 奇数拿左,偶数拿右
  */

